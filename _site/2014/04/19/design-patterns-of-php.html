<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>设计模式详解及PHP实现</title>
  <meta name="description" content="  由于工作中需要写一个比较复杂的类库，这个类库需要很高的扩展性、维护性及复用性。为了麻烦现在简单未来，使用设计模式思想来优化类库可以使工作事半功倍，在这里记录一下各种设计模式，总结一下知识，顺便也可以做为自己日后的参考。设计模式（Design Patterns）  设计模式（Design pattern）是一套...">

  <!-- CSS files -->
  <link rel="stylesheet" href="https://blog.mana.love/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://blog.mana.love/css/main.css">

  <link rel="canonical" href="https://blog.mana.love/2014/04/19/design-patterns-of-php.html">
  <link rel="alternate" type="application/rss+xml" title="喵喵清吟 | 爱菜家希望之神小飞鸟官方博客" href="https://blog.mana.love /feed.xml " />

  <!-- Icons -->
  <!-- 16x16 -->
  <!--<link rel="shortcut icon" href="https://blog.mana.love/favicon.ico">-->
   <!--32x32--> 
  <link rel="shortcut icon" href="https://blog.mana.love/img/favicon.png">
  <!--<link rel="shortcut icon" href="https://www.tuchuang001.com/images/2017/05/20/favicon.png">-->
    <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?9e7b394e0b9f2ed7bbe4edf5607e7dad";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

</head>


<body>
  <div class="row">
    <div class="col s12 m3">
      <div class="table cover">
         

<div class="cover-card table-cell table-middle">
  <!---->
  <a href="https://blog.mana.love/" class="avatar_a"><img src="" alt="" class="avatar" style="outline: 0;border: 0;"/></a>
  <!--<img src="https://www.tuchuang001.com/images/2017/05/20/site-avatar.png" alt="" class="avatar">-->
  <!---->
  <a href="https://blog.mana.love/" class="author_name">小飞鸟</a>
  <span class="author_job">爱菜家、希望之神</span>
  <span class="author_bio mbm">爱菜、爱菜、爱菜</span>
  <nav class="nav">
    <ul class="nav-list">
      <li class="nav-item">
        <a href="https://blog.mana.love/">首页</a>
        <span>/</span>
      </li>
       
      <li class="nav-item">
        <a href="https://blog.mana.love/about/">关于</a>
        
          <span>/</span>
        
      </li>
        
      <li class="nav-item">
        <a href="https://blog.mana.love/archive/">归档</a>
        
          <span>/</span>
        
      </li>
            
      <li class="nav-item">
        <a href="https://blog.mana.love/categories/">分类</a>
        
          <span>/</span>
        
      </li>
        
      <li class="nav-item">
        <a href="https://blog.mana.love/links/">友链</a>
        
          <span>/</span>
        
      </li>
          
      <li class="nav-item">
        <a href="https://blog.mana.love/tags/">标签</a>
        
          <span>/</span>
        
      </li>
                             
    </ul>
  </nav>
  <div class="social-links">
  <ul>
    <li><a href="http://github.com/ashidamana" class="social-link-item" target="_blank"><i class="fa fa-fw fa-github"></i></a></li>
    <li><a href="http://www.weibo.com/flyerangel" class="social-link-item" target="_blank"><i class="fa fa-fw fa-weibo"></i></a></li>
    
    <li><a href="mailto:flyer@mana.love" class="social-link-item" target="_blank"><i class="fa fa-fw fa-envelope"></i></a></li>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
  </ul>
</div>

</div>

      </div>
    </div>
    <div class="col s12 m9">
      <div class="post-listing">
        <!-- 判断是否插入首页图片 -->


<!-- 添加日期和阅读 -->
<div id="post">
    <header class="post-header">
        <span class="post-meta">
            <span class="post-date">
                2014-04-19
            </span> 
            •
            <span class="read-time" title="Estimated read time">
  
  
    22 mins read
  
</span>

            •
            阅读(<span data-hk-page="current"> - </span>次)<span class="pause"></span>
        </span>
        <h1 title="设计模式详解及PHP实现">设计模式详解及PHP实现</h1>
    </header>
    
    <!-- 引入google code pretiffy高亮样式 -->
    <link href="/js/google-code-prettify/themes/github-v2.css" rel="stylesheet" type="text/css" />
    
    <!-- 添加博文 -->
    <article class="post-content">
        <blockquote>
  <p>由于工作中需要写一个比较复杂的类库，这个类库需要很高的扩展性、维护性及复用性。为了麻烦现在简单未来，使用设计模式思想来优化类库可以使工作事半功倍，在这里记录一下各种设计模式，总结一下知识，顺便也可以做为自己日后的参考。</p>
</blockquote>

<h2 id="design-patterns">设计模式（Design Patterns）</h2>

<blockquote>
  <p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。   –<a href="http://baike.baidu.com/view/66964.htm">百度百科</a></p>
</blockquote>

<blockquote>
  <p>In software engineering, a design pattern is a general reusable solution to a commonly occurring problem within a given context in software design.   –<a href="http://en.wikipedia.org/wiki/Software_design_pattern">Wikipedia</a></p>
</blockquote>

<p>在软件开发过程中，一个功能的实现方式多种多样，不同方法的可扩展性、可维护性以及复用性都是不一样的。随着一个人对自己项目代码的要求增加，他会逐渐思考和实践出自己的一套方法或者思想，这种方法或思想决定了他设计出的架构或者编写出的代码的质量优劣。设计模式就属于这样一种经验的积累，是由大量优秀的工程师或者架构师总结和提炼的精华，学习好设计模式等于让我们站在了巨人的肩膀上，从一个高的起点出发，可以避免走很多弯路。</p>

<p>设计模式的使用一定是根据场景来选择的，而且设计模式的实现方式也不是固定的，我们一定要在理解现有设计模式的基础上，根据自己实际的情况不断实践不断理解。就像所谓的《泡妞大全》，读千万遍都不如实践一次来的实际。</p>

<p>如果你对设计模式完全没有感觉，那么去好好写一个类库，或者一个简单的MVC框架，这个过程会让你感觉到自己缺失的部分。</p>

<h3 id="section">分类</h3>
<p>在《设计模式：可复用面向对象软件的基础》(Design Patterns: Elements of Reusable Object-Oriented Software) 这本书中，作者把设计模式分了三大类：</p>

<h4 id="creational-patterns">创建型模式（Creational patterns）</h4>
<p><a href="http://en.wikipedia.org/wiki/Creational_pattern">创建型模式</a>是为了解决创建对象时候遇到的问题。因为基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式有两个主导思想：一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合方式。</p>

<p>最常见的五种创建型模式如下：</p>

<ul>
  <li>工厂方法模式（Factory method pattern)</li>
  <li>抽象工厂模式（Abstract factory pattern)</li>
  <li>单例模式（Singleton pattern）</li>
  <li>建造者模式（Builder pattern）</li>
  <li>原型模式（Prototype pattern）</li>
</ul>

<h4 id="structural-pattern">结构型模式（Structural pattern）</h4>
<p><a href="http://en.wikipedia.org/wiki/Structural_pattern">结构型模式</a>是通过定义一个简单的方法来实现和了解实体间关系，从而简化设计。</p>

<ul>
  <li>适配器模式（Adapter pattern）</li>
  <li>桥接模式（Bridge pattern）</li>
  <li>合成模式（Composite pattern）</li>
  <li>装饰器模式（Decorator pattern）</li>
  <li>门面模式（Facade pattern）</li>
  <li>代理模式（Proxy pattern）</li>
  <li>享元模式（Flyweight Pattern）</li>
</ul>

<h4 id="behavioral-pattern">行为型模式（Behavioral pattern）</h4>
<p><a href="http://en.wikipedia.org/wiki/Behavioral_pattern">行为型模式</a>用来识别对象之间的常用交流模式并加以实现，使得交流变得更加灵活。</p>

<ul>
  <li>策略模式（Strategy pattern）</li>
  <li>模板方法模式（Template method pattern）</li>
  <li>观察者模式（Observer pattern）</li>
  <li>迭代器模式（Iterator pattern）</li>
  <li>责任链模式（Chain of responsibility pattern）</li>
  <li>命令模式（Command pattern）</li>
  <li>备忘录模式（Memento pattern）</li>
  <li>状态模式（State pattern）</li>
  <li>访问者模式（Visitor pattern）</li>
  <li>中介者模式（Mediator pattern）</li>
  <li>解释器模式（Interpreter pattern）</li>
</ul>

<h3 id="section-1">关系</h3>
<p>这里有一张各个模式关系图，可以在了解各个模式以后梳理一下</p>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-design-patterns.jpg" alt="设计模式" /></p>

<h3 id="section-2">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Software_design_pattern">Wikipedia: Software design pattern</a></li>
  <li><a href="http://baike.baidu.com/view/66964.htm">百度百科：设计模式</a></li>
</ol>

<h2 id="builder-pattern">建造者模式（Builder pattern）</h2>
<p>建造者模式是一种创建型模式，它可以让一个产品的内部表象和和产品的生产过程分离开，从而可以生成具有不同内部表象的产品。</p>

<h3 id="builder">Builder模式中主要角色</h3>

<ul>
  <li>抽象建造者(Builder)角色：定义抽象接口，规范产品各个部分的建造，必须包括建造方法和返回方法。</li>
  <li>具体建造者(Concrete)角色：实现抽象建造者接口。应用程序最终根据此角色中实现的业务逻辑创造产品。</li>
  <li>导演者(Director)角色：调用具体的建造者角色创造产品。</li>
  <li>产品(Product)角色：在导演者的指导下所创建的复杂对象。</li>
</ul>

<h3 id="section-3">适用性</h3>

<ul>
  <li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
  <li>当构造过程必须允许被构造的对象有不同的表示时。</li>
</ul>

<h3 id="section-4">类图</h3>
<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-builder-pattern-uml.png" alt="builder pattern" /></p>

<h3 id="section-5">实例</h3>

<p>```php
&lt;?php</p>

<p>class Product { // 产品本身
    private $_parts; 
    public function __construct() { $this-&gt;_parts = array(); } 
    public function add($part) { return array_push($this-&gt;_parts, $part); }
}</p>

<p>abstract class Builder { // 建造者抽象类
    public abstract function buildPart1();
    public abstract function buildPart2();
    public abstract function getResult();
}</p>

<p>class ConcreteBuilder extends Builder { // 具体建造者
    private $_product;
    public function __construct() { $this-&gt;_product = new Product(); }
    public function buildPart1() { $this-&gt;_product-&gt;add(“Part1”); } 
    public function buildPart2() { $this-&gt;_product-&gt;add(“Part2”); }
    public function getResult() { return $this-&gt;_product; }
}</p>

<p>class Director { 
    public function __construct(Builder $builder) {
        $builder-&gt;buildPart1();
        $builder-&gt;buildPart2();
    }
}</p>

<p>// client 
$buidler = new ConcreteBuilder();
$director = new Director($buidler);
$product = $buidler-&gt;getResult();
?&gt;
```</p>

<h3 id="section-6">优缺点</h3>

<h4 id="section-7">优点</h4>
<p>建造者模式可以很好的将一个对象的实现与相关的“业务”逻辑分离开来，从而可以在不改变事件逻辑的前提下，使增加(或改变)实现变得非常容易。</p>

<h4 id="section-8">缺点</h4>
<p>建造者接口的修改会导致所有执行类的修改。</p>

<h3 id="section-9">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Builder_pattern">Wikipedia: Bulider pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F">Wikipedia: 生成器模式</a></li>
  <li><a href="http://www.phppan.com/2010/05/php-design-pattern-2-builder/">PHP设计模式笔记：使用PHP实现建造者模式</a></li>
</ol>

<h2 id="singleton-pattern">单例模式（Singleton pattern）</h2>
<p>抽象工厂模式是一种创建型模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在。</p>

<p>实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>

<h3 id="section-10">单例模式中主要角色</h3>
<p>Singleton定义一个getInstance操作，允许客户访问它唯一的实例。</p>

<p>这个例子也简单，就像我有6个老婆（快醒醒!），她们在喊”老公”的时候都是指我。不管什么时候，喊老公擦地，做饭，洗衣服都是指同一个人，PHP不编写多线程，所以不存在抢占问题，如果换别的语言编写，一定得考虑到抢占问题！老公是不可以边擦地边做饭的！</p>

<h3 id="section-11">适用性</h3>

<ul>
  <li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时</li>
  <li>当这个唯一实例应该是通过子类化可扩展的。并且用户应该无需更改代码就能使用一个扩展的实例时。</li>
</ul>

<h3 id="section-12">类图</h3>
<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-singleton-pattern-uml.png" alt="singleton pattern" /></p>

<h3 id="section-13">实例</h3>

<p>```php
&lt;?php 
public class Singleton {
    private static $_instance = NULL;</p>

<pre><code>// 私有构造方法 
private function __construct() {}

public static function getInstance() {
    if (is_null(self::$_instance)) {
        self::$_instance = new Singleton();
    }
    return self::$_instance;
}

// 防止克隆实例
public function __clone(){
    die('Clone is not allowed.' . E_USER_ERROR);
} } ?&gt; ```
</code></pre>

<p>在此实例中，Singleton禁止了克隆及外部初始化，使得此类只可以通过<code>getInstance()</code>方法来获得实例，而这个实例只会在第一次使用时创建，以后每次都获得同一实例。</p>

<h3 id="section-14">优缺点</h3>
<p>#### 优点
- 对唯一实例的受控访问
- 缩小命名空间 单例模式是对全局变量的一种改进。它避免了那些存储唯一实例的全局变量污染命名空间
- 允许对操作和表示的精华，单例类可以有子类。而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你所需要的类的实例在运行时刻配置应用。
- 允许可变数目的实例（多例模式）
- 比类操作更灵活</p>

<h4 id="section-15">缺点</h4>
<p>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p>

<h3 id="section-16">参考</h3>
<ol>
  <li><a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">Wikipedia: 单例模式</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Singleton_pattern">Wikipedia: Singleton pattern</a></li>
  <li><a href="http://www.phppan.com/2010/06/php-design-pattern-6-singleton/">PHP设计模式笔记：使用PHP实现单例模式</a></li>
</ol>

<h2 id="adapter-pattern">适配器模式（Adapter pattern）</h2>
<p>适配器模式是一种结构型模式，它将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类别自己的接口包裹在一个已存在的类中。</p>

<h3 id="section-17">适配器模式中主要角色</h3>

<ul>
  <li>目标(Target)角色：定义客户端使用的与特定领域相关的接口，这也就是我们所期待得到的</li>
  <li>源(Adaptee)角色：需要进行适配的接口</li>
  <li>适配器(Adapter)角色：对Adaptee的接口与Target接口进行适配；适配器是本模式的核心，适配器把源接口转换成目标接口，此角色为具体类</li>
</ul>

<h3 id="section-18">适用性</h3>
<p>1、你想使用一个已经存在的类，而它的接口不符合你的需求
2、你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作
3、你想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口（仅限于对象适配器）</p>

<h3 id="section-19">类适配器模式与对象适配器</h3>

<p>类适配器：Adapter与Adaptee是继承关系</p>

<ul>
  <li>用一个具体的Adapter类和Target进行匹配。结果是当我们想要一个匹配一个类以及所有它的子类时，类Adapter将不能胜任工作</li>
  <li>使得Adapter可以重定义Adaptee的部分行为，因为Adapter是Adaptee的一个子集</li>
  <li>仅仅引入一个对象，并不需要额外的指针以间接取得adaptee</li>
</ul>

<p>对象适配器：Adapter与Adaptee是委托关系</p>

<ul>
  <li>允许一个Adapter与多个Adaptee同时工作。Adapter也可以一次给所有的Adaptee添加功能</li>
  <li>使用重定义Adaptee的行为比较困难</li>
</ul>

<h3 id="section-20">类图</h3>

<h4 id="section-21">类适配器</h4>
<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-class-adapter-pattern-uml.jpg" alt="class adapter pattern" /></p>

<h4 id="section-22">对象适配器</h4>
<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-object-adapter-pattern-uml.jpg" alt="object adapter pattern" /></p>

<h3 id="section-23">实例</h3>

<h4 id="section-24">类适配器</h4>

<p>```php
&lt;?php</p>

<p>interface Target {
    public function sampleMethod1();
    public function sampleMethod2();
}</p>

<p>class Adaptee { // 源角色
    public function sampleMethod1() {}
}</p>

<p>class Adapter extends Adaptee implements Target { // 适配后角色
    public function sampleMethod2() {} 
}</p>

<p>// client
$adapter = new Adapter();
$adapter-&gt;sampleMethod1();
$adapter-&gt;sampleMethod2();</p>

<p>?&gt;
```</p>

<h4 id="section-25">对象适配器</h4>

<p>```php
&lt;?php</p>

<p>interface Target {
    public function sampleMethod1();
    public function sampleMethod2();
}</p>

<p>class Adaptee {
    public function sampleMethod1() {}
}</p>

<p>class Adapter implements Target {
    private $_adaptee;
    public function __construct(Adaptee $adaptee) {
        $this-&gt;_adaptee = $adaptee;
    }</p>

<pre><code>public function sampleMethod1() { $this-&gt;_adaptee-&gt;sampleMethod1(); }
 
public function sampleMethod2() {} }
</code></pre>

<p>$adaptee = new Adaptee();
$adapter = new Adapter($adaptee);
$adapter-&gt;sampleMethod1();
$adapter-&gt;sampleMethod2();
?&gt;
```</p>

<h3 id="section-26">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Adapter_pattern">Wikipedia: Adapter pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">Wikipedia: 适配器模式</a></li>
  <li><a href="http://www.phppan.com/2010/07/php-design-pattern-10-adapter/">PHP设计模式笔记：使用PHP实现适配器模式</a></li>
</ol>

<h2 id="bridge-pattern">桥接模式（Bridge pattern）</h2>
<p>桥接模式是一种结构型模式，它是软件设计模式中最复杂的模式之一，它把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”。</p>

<h3 id="section-27">主要角色</h3>

<ul>
  <li>抽象化(Abstraction)角色：定义抽象类的接口并保存一个对实现化对象的引用。</li>
  <li>修正抽象化(Refined Abstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。</li>
  <li>实现化(Implementor)角色：定义实现类的接口，不给出具体的实现。此接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以完全不同。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。</li>
  <li>具体实现化(Concrete Implementor)角色：实现实现化角色接口并定义它的具体实现。</li>
</ul>

<h3 id="section-28">适用性</h3>
<ul>
  <li>如果一个系统需要在构件的抽象化和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。</li>
  <li>设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。</li>
  <li>一个构件有多于一个的抽象化角色和实现化角色，并且系统需要它们之间进行动态的耦合。</li>
  <li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li>
</ul>

<h3 id="section-29">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-bridge-pattern-uml.jpg" alt="bridge pattern" /></p>

<h3 id="section-30">实例</h3>

<p>```php
&lt;?php
abstract class Abstraction { // 抽象化角色，抽象化给出的定义，并保存一个对实现化对象的引用。  <br />
    protected $imp; // 对实现化对象的引用
    public function operation() {
        $this-&gt;imp-&gt;operationImp();
    }
}</p>

<p>class RefinedAbstraction extends Abstraction { // 修正抽象化角色, 扩展抽象化角色，改变和修正父类对抽象化的定义。
     public function __construct(Implementor $imp) {
        $this-&gt;imp = $imp;
    }
    public function operation() { $this-&gt;imp-&gt;operationImp(); }
}</p>

<p>abstract class Implementor { // 实现化角色, 给出实现化角色的接口，但不给出具体的实现。
    abstract public function operationImp();
}</p>

<p>class ConcreteImplementorA extends Implementor { // 具体化角色A
    public function operationImp() {}
}</p>

<p>class ConcreteImplementorB extends Implementor { // 具体化角色B
    public function operationImp() {}
}</p>

<p>// client
$abstraction = new RefinedAbstraction(new ConcreteImplementorA());
$abstraction-&gt;operation();</p>

<p>$abstraction = new RefinedAbstraction(new ConcreteImplementorB());
$abstraction-&gt;operation();
?&gt;
```</p>

<h3 id="section-31">优点</h3>
<ul>
  <li>分离接口及其实现部分, 将Abstraction与Implementor分享有助于降低对实现部分编译时刻的依赖性, 接口与实现分享有助于分层，从而产生更好的结构化系统</li>
  <li>提高可扩充性</li>
  <li>实现细节对客户透明。</li>
</ul>

<h3 id="section-32">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Bridge_pattern">Wikipedia: Bridge pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E6%A9%8B%E6%8E%A5%E6%A8%A1%E5%BC%8F">Wikipedia: 桥接模式</a></li>
  <li><a href="http://www.phppan.com/2010/06/php-design-pattern-5-bridge/">PHP设计模式笔记：使用PHP实现桥接模式</a></li>
</ol>

<h2 id="composite-pattern">合成模式（Composite pattern）</h2>
<p>合成模式是一种结构型模式，它将对象组合成树形结构以表示”部分-整体”的层次结构。Composite使用户对单个对象和组合对象的使用具有一致性。
Composite变化的是一个对象的结构和组成。</p>

<h3 id="section-33">主要角色</h3>

<ul>
  <li>抽象组件(Component)角色：抽象角色，给参加组合的对象规定一个接口。在适当的情况下，实现所有类共有接口的缺省行为。声明一个接口用于访问和管理Component的子组件</li>
  <li>树叶组件(Leaf)角色：在组合中表示叶节点对象，叶节点没有子节点。在组合中定义图元对象的行为。</li>
  <li>树枝组件(Composite)角色：存储子部件。定义有子部件的那些部件的行为。在Component接口中实现与子部件有关的操作。</li>
  <li>客户端(Client)：通过Component接口操纵组合部件的对象</li>
</ul>

<h3 id="section-34">适用性</h3>

<ul>
  <li>你想表示对象的部分-整体层次结构。</li>
  <li>你希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
</ul>

<h3 id="section-35">类图</h3>

<h4 id="section-36">安全式合成模式</h4>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-safe-composite-pattern-uml.jpg" alt="safe composite pattern" /></p>

<h4 id="section-37">透明式合成模式</h4>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-transparent-composite-pattern-uml.jpg" alt="transparent composite pattern" /></p>

<h3 id="section-38">实例</h3>

<h4 id="section-39">安全式合成模式</h4>

<p>在Composite类里面声明所有的用来管理子类对象的方法。这样的做法是安全的。因为树叶类型的对象根本就没有管理子类的方法，因此，如果客户端对树叶类对象使用这些方法时，程序会在编译时期出错。编译通不过，就不会出现运行时期错误。这样的缺点是不够透明，因为树叶类和合成类将具有不同的接口。</p>

<p>```php
&lt;?php
interface Component {
    public function getComposite(); //返回自己的实例
    public function operation();
}</p>

<p>class Composite implements Component { // 树枝组件角色
    private $_composites;
    public function __construct() { $this-&gt;_composites = array(); }
    public function getComposite() { return $this; }
     public function operation() {
         foreach ($this-&gt;_composites as $composite) {
            $composite-&gt;operation();
        }
     }</p>

<pre><code>public function add(Component $component) {  //聚集管理方法 添加一个子对象
    $this-&gt;_composites[] = $component;
}
 
public function remove(Component $component) { // 聚集管理方法 删除一个子对象
    foreach ($this-&gt;_composites as $key =&gt; $row) {
        if ($component == $row) { unset($this-&gt;_composites[$key]); return TRUE; }
    } 
    return FALSE;
}

public function getChild() { // 聚集管理方法 返回所有的子对象
   return $this-&gt;_composites;
}
</code></pre>

<p>}</p>

<p>class Leaf implements Component {
    private $_name; 
    public function __construct($name) { $this-&gt;_name = $name; }
    public function operation() {}
    public function getComposite() {return null;}
}</p>

<p>// client
$leaf1 = new Leaf(‘first’);
$leaf2 = new Leaf(‘second’);</p>

<p>$composite = new Composite();
$composite-&gt;add($leaf1);
$composite-&gt;add($leaf2);
$composite-&gt;operation();</p>

<p>$composite-&gt;remove($leaf2);
$composite-&gt;operation();
?&gt;
```</p>

<h4 id="section-40">透明式合成模式</h4>
<p>在Composite类里面声明所有的用来管理子类对象的方法。这样做的是好处是所有的组件类都有相同的接口。在客户端看来，树叶类和合成类对象的区别起码在接口层次上消失了，客户端可以同等的对待所有的对象。这就是透明形式的合成模式，缺点就是不够安全，因为树叶类对象和合成类对象在本质上是有区别的。树叶类对象不可能有下一个层次的对象，因此调用其添加或删除方法就没有意义了，这在编译期间是不会出错的，而只会在运行时期才会出错。</p>

<p>```php
&lt;?php
interface Component { // 抽象组件角色
    public function getComposite(); // 返回自己的实例
    public function operation(); // 示例方法
    public function add(Component $component); // 聚集管理方法,添加一个子对象
    public function remove(Component $component); // 聚集管理方法 删除一个子对象
    public function getChild(); // 聚集管理方法 返回所有的子对象
}</p>

<p>class Composite implements Component { // 树枝组件角色
    private $_composites;
    public function __construct() { $this-&gt;_composites = array(); } 
    public function getComposite() { return $this; }
    public function operation() { // 示例方法，调用各个子对象的operation方法
        foreach ($this-&gt;_composites as $composite) {
            $composite-&gt;operation();
        }
    }
    public function add(Component $component) { // 聚集管理方法 添加一个子对象
        $this-&gt;_composites[] = $component;
    }
    public function remove(Component $component) { // 聚集管理方法 删除一个子对象
        foreach ($this-&gt;_composites as $key =&gt; $row) {
            if ($component == $row) { unset($this-&gt;_composites[$key]); return TRUE; }
        } 
        return FALSE;
    }
    public function getChild() { // 聚集管理方法 返回所有的子对象
       return $this-&gt;_composites;
    }</p>

<p>}</p>

<p>class Leaf implements Component {
    private $_name;
    public function __construct($name) {$this-&gt;_name = $name;}
    public function operation() {}
    public function getComposite() { return null; }
    public function add(Component $component) { return FALSE; }
    public function remove(Component $component) { return FALSE; }
    public function getChild() { return null; }
}</p>

<p>// client 
$leaf1 = new Leaf(‘first’);
$leaf2 = new Leaf(‘second’);</p>

<p>$composite = new Composite();
$composite-&gt;add($leaf1);
$composite-&gt;add($leaf2);
$composite-&gt;operation();</p>

<p>$composite-&gt;remove($leaf2);
$composite-&gt;operation();
?&gt;
```</p>

<h3 id="section-41">优缺点</h3>
<p>#### 优点</p>

<ul>
  <li>简化客户代码</li>
  <li>使得更容易增加新类型的组件</li>
</ul>

<h4 id="section-42">缺点</h4>

<ul>
  <li>使你的设计变得更加一般化，容易增加组件也会产生一些问题，那就是很难限制组合中的组件</li>
</ul>

<h3 id="section-43">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Composite_pattern">Wikipedia: Composite pattern</a></li>
  <li><a href="http://www.phppan.com/2010/08/php-design-pattern-14-composite/">PHP设计模式笔记：使用PHP实现合成模式</a></li>
</ol>

<h2 id="decorator-pattern">装饰器模式（Decorator pattern）</h2>
<p>装饰器模式是一种结构型模式，它动态的给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活【GOF95】
装饰模式是以对客户透明的方式动态地给一个对象附加上更多的职责。这也就是说，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。</p>

<h3 id="section-44">主要角色</h3>

<ul>
  <li>抽象构件(Component)角色：定义一个对象接口，以规范准备接收附加职责的对象，从而可以给这些对象动态地添加职责。</li>
  <li>具体构件(Concrete Component)角色：定义一个将要接收附加职责的类。</li>
  <li>装饰(Decorator)角色：持有一个指向Component对象的指针，并定义一个与Component接口一致的接口。</li>
  <li>具体装饰(Concrete Decorator)角色：负责给构件对象增加附加的职责。</li>
</ul>

<h3 id="section-45">适用性</h3>

<ul>
  <li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li>
  <li>处理那些可以撤消的职责，即需要动态的给一个对象添加功能并且这些功能是可以动态的撤消的。</li>
  <li>当不能彩生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。</li>
</ul>

<h3 id="section-46">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-decorator-pattern-uml.jpg" alt="decorator pattern" /></p>

<h3 id="section-47">实例</h3>

<p>```php
&lt;?php
interface Component {
    public function operation();
}</p>

<p>abstract class Decorator implements Component{ // 装饰角色 
    protected  $_component;
    public function __construct(Component $component) {
        $this-&gt;_component = $component;
    }
    public function operation() {
        $this-&gt;_component-&gt;operation();
    }
}</p>

<p>class ConcreteDecoratorA extends Decorator { // 具体装饰类A
    public function __construct(Component $component) {
        parent::__construct($component);
    } 
    public function operation() {
        parent::operation();    //  调用装饰类的操作
        $this-&gt;addedOperationA();   //  新增加的操作
    }
    public function addedOperationA() {}
}</p>

<p>class ConcreteDecoratorB extends Decorator { // 具体装饰类B
    public function __construct(Component $component) {
        parent::__construct($component);
    } 
    public function operation() {
        parent::operation();
        $this-&gt;addedOperationB();
    }
    public function addedOperationB() {}
}</p>

<p>class ConcreteComponent implements Component{ 
    public function operation() {} 
}</p>

<p>// clients
$component = new ConcreteComponent();
$decoratorA = new ConcreteDecoratorA($component);
$decoratorB = new ConcreteDecoratorB($decoratorA);</p>

<p>$decoratorA-&gt;operation();
$decoratorB-&gt;operation();
?&gt;
```</p>

<h3 id="section-48">优缺点</h3>

<h4 id="section-49">优点</h4>
<ul>
  <li>比静态继承更灵活；</li>
  <li>避免在层次结构高层的类有太多的特征</li>
</ul>

<h4 id="section-50">缺点</h4>
<ul>
  <li>使用装饰模式会产生比使用继承关系更多的对象。并且这些对象看上去都很想像，从而使得查错变得困难。</li>
</ul>

<h3 id="section-51">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Decorator_pattern">Wikipedia: Decorator pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F">Wikipedia: 修饰模式</a></li>
  <li><a href="http://www.phppan.com/2010/06/php-design-pattern-4-decorator/">PHP设计模式笔记：使用PHP实现装饰模式</a></li>
</ol>

<h2 id="facade-pattern">门面模式（Facade pattern）</h2>
<p>门面模式是一种结构型模式，它为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层次的接口，使得子系统更加容易使用。</p>

<h3 id="section-52">主要角色</h3>

<h4 id="facade">门面(Facade)角色</h4>

<ul>
  <li>此角色将被客户端调用</li>
  <li>知道哪些子系统负责处理请求</li>
  <li>将用户的请求指派给适当的子系统</li>
</ul>

<h4 id="subsystem">子系统(subsystem)角色</h4>

<ul>
  <li>实现子系统的功能</li>
  <li>处理由Facade对象指派的任务</li>
  <li>没有Facade的相关信息，可以被客户端直接调用</li>
  <li>可以同时有一个或多个子系统，每个子系统都不是一个单独的类，而一个类的集合。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并知道门面模式的存在，对于子系统而言，门面仅仅是另一个客户端。</li>
</ul>

<h3 id="section-53">适用性</h3>

<ul>
  <li>为一些复杂的子系统提供一组接口</li>
  <li>提高子系统的独立性</li>
  <li>在层次化结构中，可以使用门面模式定义系统的每一层的接口</li>
</ul>

<h3 id="section-54">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-facade-pattern-uml.jpg" alt="facade pattern" /></p>

<h3 id="section-55">实例</h3>

<p>```php
&lt;?php
class Camera {
    public function turnOn() {}
    public function turnOff() {}
    public function rotate($degrees) {}
}</p>

<p>class Light {
    public function turnOn() {}
    public function turnOff() {}
    public function changeBulb() {}
}</p>

<p>class Sensor {
    public function activate() {}
    public function deactivate() {}
    public function trigger() {}
}</p>

<p>class Alarm {
    public function activate() {}
    public function deactivate() {}
    public function ring() {}
    public function stopRing() {}
}</p>

<p>class SecurityFacade {
    private $_camera1, $_camera2;
    private $_light1, $_light2, $_light3;
    private $_sensor;
    private $_alarm;</p>

<pre><code>public function __construct() {
    $this-&gt;_camera1 = new Camera();
    $this-&gt;_camera2 = new Camera();
 
    $this-&gt;_light1 = new Light();
    $this-&gt;_light2 = new Light();
    $this-&gt;_light3 = new Light();
 
    $this-&gt;_sensor = new Sensor();
    $this-&gt;_alarm = new Alarm();
}
 
public function activate() {
    $this-&gt;_camera1-&gt;turnOn();
    $this-&gt;_camera2-&gt;turnOn();
 
    $this-&gt;_light1-&gt;turnOn();
    $this-&gt;_light2-&gt;turnOn();
    $this-&gt;_light3-&gt;turnOn();
 
    $this-&gt;_sensor-&gt;activate();
    $this-&gt;_alarm-&gt;activate();
}
 
public  function deactivate() {
    $this-&gt;_camera1-&gt;turnOff();
    $this-&gt;_camera2-&gt;turnOff();
 
    $this-&gt;_light1-&gt;turnOff();
    $this-&gt;_light2-&gt;turnOff();
    $this-&gt;_light3-&gt;turnOff();
 
    $this-&gt;_sensor-&gt;deactivate();
    $this-&gt;_alarm-&gt;deactivate();
} }
</code></pre>

<p>//client 
$security = new SecurityFacade();
$security-&gt;activate();
?&gt;
```</p>

<h3 id="section-56">优缺点</h3>

<h4 id="section-57">优点</h4>

<ul>
  <li>它对客户屏蔽了子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便</li>
  <li>实现了子系统与客户之间的松耦合关系</li>
  <li>如果应用需要，它并不限制它们使用子系统类。因此可以在系统易用性与能用性之间加以选择</li>
</ul>

<h3 id="section-58">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Facade_pattern">Wikipedia: Facade pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E5%A4%96%E8%A7%80%E6%A8%A1%E5%BC%8F">Wikipedia: 外观模式</a></li>
  <li><a href="http://www.phppan.com/2010/06/php-design-pattern-7-facade/">PHP设计模式笔记：使用PHP实现门面模式</a></li>
</ol>

<h2 id="flyweight-pattern">享元模式（Flyweight Pattern）</h2>
<p>享元模式是一种结构型模式，它使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。</p>

<h3 id="section-59">主要角色</h3>

<ul>
  <li>抽象享元(Flyweight角色：此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。那些需要外蕴状态的操作可以通过调用商业以参数形式传入</li>
  <li>具体享元(ConcreteFlyweight角色：实现Flyweight接口，并为内部状态（如果有的话）拉回存储空间。ConcreteFlyweight对象必须是可共享的。它所存储的状态必须是内部的</li>
  <li>不共享的具体享元（UnsharedConcreteFlyweight）角色：并非所有的Flyweight子类都需要被共享。Flyweigth使共享成为可能，但它并不强制共享。</li>
  <li>享元工厂(FlyweightFactory)角色：负责创建和管理享元角色。本角色必须保证享元对象可能被系统适当地共享</li>
  <li>客户端(Client)角色：本角色需要维护一个对所有享元对象的引用。本角色需要自行存储所有享元对象的外部状态</li>
</ul>

<h3 id="section-60">适用性</h3>

<ul>
  <li>一个应用程序使用了大量的对象</li>
  <li>完全由于使用大量的对象，造成很大的存储开销</li>
  <li>对象的大多数状态都可变为外部状态</li>
  <li>如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象</li>
  <li>应用程序不依赖于对象标识。</li>
</ul>

<h3 id="section-61">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-flyweight-pattern-uml.jpg" alt="flyweight pattern" /></p>

<h3 id="section-62">实例</h3>

<p>```php
&lt;?php
abstract class Flyweight { // 抽象享元角色
    abstract public function operation($state);
}</p>

<p>class ConcreteFlyweight extends Flyweight { // 具体享元角色
    private $_intrinsicState = null; 
    public function __construct($state) {
        $this-&gt;_intrinsicState = $state;
    }
    public function operation($state) {}
}</p>

<p>class UnsharedConcreteFlyweight extends Flyweight { // 不共享的具体享元，客户端直接调用
    private $_intrinsicState = null;
    public function __construct($state) {
        $this-&gt;_intrinsicState = $state;
    }
    public function operation($state) {}
}</p>

<p>class FlyweightFactory { // 享元工厂角色 
    private $_flyweights;
    public function __construct() {
        $this-&gt;_flyweights = array();
    }
    public function getFlyweigth($state) {
        if (isset($this-&gt;_flyweights[$state])) {
            return $this-&gt;_flyweights[$state];
        } else {
            return $this-&gt;_flyweights[$state] = new ConcreteFlyweight($state);
        }
    }
}</p>

<p>// client
$flyweightFactory = new FlyweightFactory();
$flyweight = $flyweightFactory-&gt;getFlyweigth(‘state A’);
$flyweight-&gt;operation(‘other state A’);</p>

<p>$flyweight = $flyweightFactory-&gt;getFlyweigth(‘state B’);
$flyweight-&gt;operation(‘other state B’);</p>

<p>// 不共享的对象，单独调用
$uflyweight = new UnsharedConcreteFlyweight(‘state A’);
$uflyweight-&gt;operation(‘other state A’);
?&gt;
```</p>

<h3 id="section-63">优缺点</h3>

<h4 id="section-64">优点</h4>

<ul>
  <li>Flyweight模式可以大幅度地降低内存中对象的数量。</li>
</ul>

<h4 id="section-65">缺点</h4>

<ul>
  <li>Flyweight模式使得系统更加复杂</li>
  <li>Flyweigth模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长</li>
</ul>

<h3 id="section-66">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Flyweight_pattern">Wikipedia: Flyweight pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F">Wikipedia: 享元模式</a></li>
  <li><a href="http://www.phppan.com/2010/08/php-design-pattern-13-flyweight/">PHP设计模式笔记：使用PHP实现享元模式</a></li>
</ol>

<h2 id="observer-pattern">观察者模式（Observer pattern）</h2>
<p>观察者模式是一种行为型模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>

<p>又称为发布-订阅（Publish-Subscribe）模式、模型-视图（Model-View）模式、源-监听（Source-Listener）模式、或从属者(Dependents)模式</p>

<h3 id="section-67">主要角色</h3>

<ul>
  <li>抽象主题（Subject）角色：主题角色将所有对观察者对象的引用保存在一个集合中，每个主题可以有任意多个观察者。抽象主题提供了增加和删除观察者对象的接口。</li>
  <li>抽象观察者（Observer）角色：为所有的具体观察者定义一个接口，在观察的主题发生改变时更新自己。</li>
  <li>具体主题（ConcreteSubject）角色：存储相关状态到具体观察者对象，当具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。</li>
  <li>具体观察者（ConcretedObserver）角色：存储一个具体主题对象，存储相关状态，实现抽象观察者角色所要求的更新接口，以使得其自身状态和主题的状态保持一致。</li>
</ul>

<h3 id="section-68">适用性</h3>

<ul>
  <li>当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。</li>
  <li>当对一个对象的改变需要同时改变其它对象，而不知道具体有多少个对象待改变。</li>
  <li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换句话说，你不希望这些对象是紧密耦合的。</li>
</ul>

<h3 id="section-69">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-observer-pattern-uml.jpg" alt="observer pattern" /></p>

<h3 id="section-70">实例</h3>

<p>```php
&lt;?php
interface Subject { // 抽象主题角色
    public function attach(Observer $observer); // 增加一个新的观察者对象
    public function detach(Observer $observer); // 删除一个已注册过的观察者对象
    public function notifyObservers(); // 通知所有注册过的观察者对象
}</p>

<p>class ConcreteSubject implements Subject { // 具体主题角色
    private $_observers; 
    public function __construct() { $this-&gt;_observers = array(); }
    public function attach(Observer $observer) {
        return array_push($this-&gt;_observers, $observer);
    }
    public function detach(Observer $observer) {
        $index = array_search($observer, $this-&gt;_observers);
        if ($index === FALSE || ! array_key_exists($index, $this-&gt;_observers)) {
            return FALSE;
        } 
        unset($this-&gt;_observers[$index]);
        return TRUE;
    }
    public function notifyObservers() {
        if (!is_array($this-&gt;_observers)) { return FALSE; } 
        foreach ($this-&gt;_observers as $observer) { 
            $observer-&gt;update(); 
        } 
        return TRUE;
    }</p>

<p>}</p>

<p>interface Observer { // 抽象观察者角色
    public function update(); // 更新方法
}</p>

<p>class ConcreteObserver implements Observer {
    private $_name; 
    public function __construct($name) { $this-&gt;_name = $name; }
    public function update() {}
}</p>

<p>$subject = new ConcreteSubject();</p>

<p>/* 添加第一个观察者 */
$observer1 = new ConcreteObserver(‘Mac’);
$subject-&gt;attach($observer1);
$subject-&gt;notifyObservers(); // 主题变化，通知观察者</p>

<p>/* 添加第二个观察者 */
$observer2 = new ConcreteObserver(‘Win’);
$subject-&gt;attach($observer2);
$subject-&gt;notifyObservers();</p>

<p>$subject-&gt;detach($observer1);
$subject-&gt;notifyObservers();
?&gt;
```</p>

<h3 id="section-71">优缺点</h3>

<h4 id="section-72">优点</h4>

<ul>
  <li>观察者和主题之间的耦合度较小。</li>
  <li>支持广播通信。</li>
</ul>

<h4 id="section-73">缺点</h4>

<ul>
  <li>由于观察者并不知道其它观察者的存在，它可能对改变目标的最终代价一无所知。这可能会引起意外的更新。</li>
</ul>

<h3 id="section-74">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Observer_pattern">Wikipedia: Observer pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">Wikipedia: 观察者模式</a></li>
  <li><a href="http://www.phppan.com/2010/09/php-design-pattern-17-observer/">PHP设计模式笔记：使用PHP实现观察者模式</a></li>
</ol>

<h2 id="prototype-pattern">原型模式（Prototype pattern）</h2>
<p>原型模式是一种创建者模式，其特点在于通过“复制”一个已经存在的实例来返回新的实例,而不是新建实例。</p>

<h3 id="section-75">原型模式中主要角色</h3>

<ul>
  <li>抽象原型(Prototype)角色：声明一个克隆自己的接口</li>
  <li>具体原型(Concrete Prototype)角色：实现一个克隆自己的操作</li>
</ul>

<h3 id="section-76">适用性</h3>

<ul>
  <li>当一个系统应该独立于它的产品创建、构成和表示时，要使用Prototype模式</li>
  <li>当要实例化的类是在运行时刻指定时，例如动态加载</li>
  <li>为了避免创建一个与产品类层次平等的工厂类层次时；</li>
  <li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些</li>
</ul>

<h3 id="section-77">类图</h3>
<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-prototype-pattern-uml.jpg" alt="prototype pattern" /></p>

<h3 id="section-78">实例</h3>

<p>```php
&lt;?php</p>

<p>interface Prototype { public function copy(); }</p>

<p>class ConcretePrototype implements Prototype{
    private  $_name;
    public function __construct($name) { $this-&gt;_name = $name; } 
    public function copy() { return clone $this;}
}</p>

<p>class Demo {}</p>

<p>// client</p>

<p>$demo = new Demo();
$object1 = new ConcretePrototype($demo);
$object2 = $object1-&gt;copy();
?&gt;
```</p>

<h3 id="section-79">优缺点</h3>

<h4 id="section-80">优点</h4>
<ul>
  <li>可以在运行时刻增加和删除产品</li>
  <li>可以改变值以指定新对象</li>
  <li>可以改变结构以指定新对象</li>
  <li>减少子类的构造</li>
  <li>用类动态配置应用</li>
</ul>

<h4 id="section-81">缺点</h4>
<p>Prototype模式的最主要缺点就是每一个类必须配备一个克隆方法。而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事。</p>

<h3 id="section-82">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Prototype_pattern">Wikipedia: Prototype pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">Wikipedia: 原型模式</a></li>
  <li><a href="http://www.phppan.com/2010/06/php-design-pattern-8-prototype/">PHP设计模式笔记：使用PHP实现原型模式</a></li>
</ol>

<h2 id="proxy-pattern">代理模式（Proxy pattern）</h2>
<p>代理模式是一种结构型模式，它可以为其他对象提供一种代理以控制对这个对象的访问。</p>

<h3 id="section-83">主要角色</h3>

<ul>
  <li>抽象主题角色(Subject)：它的作用是统一接口。此角色定义了真实主题角色和代理主题角色共用的接口，这样就可以在使用真实主题角色的地方使用代理主题角色。</li>
  <li>真实主题角色(RealSubject)：隐藏在代理角色后面的真实对象。</li>
  <li>代理主题角色(ProxySubject)：它的作用是代理真实主题，在其内部保留了对真实主题角色的引用。它与真实主题角色都继承自抽象主题角色，保持接口的统一。它可以控制对真实主题的存取，并可能负责创建和删除真实对象。代理角色并不是简单的转发，通常在将调用传递给真实对象之前或之后执行某些操作，当然你也可以只是简单的转发。 与适配器模式相比：适配器模式是为了改变对象的接口，而代理模式并不能改变所代理对象的接口。</li>
</ul>

<h3 id="section-84">适用性</h3>

<ul>
  <li>为一些复杂的子系统提供一组接口</li>
  <li>提高子系统的独立性</li>
  <li>在层次化结构中，可以使用门面模式定义系统的每一层的接口</li>
</ul>

<h3 id="section-85">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-proxy-pattern-uml.png" alt="proxy pattern" /></p>

<h3 id="section-86">实例</h3>

<p>```php
&lt;?php
abstract class Subject { // 抽象主题角色
    abstract public function action();
}</p>

<p>class RealSubject extends Subject { // 真实主题角色
    public function __construct() {}
    public function action() {}
}</p>

<p>class ProxySubject extends Subject { // 代理主题角色
    private $_real_subject = NULL;
    public function __construct() {}</p>

<pre><code>public function action() {
    $this-&gt;_beforeAction();
    if (is_null($this-&gt;_real_subject)) {
        $this-&gt;_real_subject = new RealSubject();
    }
    $this-&gt;_real_subject-&gt;action();
    $this-&gt;_afterAction();
}
private function _beforeAction() {}
private function _afterAction() {} }
</code></pre>

<p>// client
$subject = new ProxySubject();
$subject-&gt;action();
?&gt;
```</p>

<h3 id="section-87">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Proxy_pattern">Wikipedia: Proxy pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F">Wikipedia: 代理模式</a></li>
  <li><a href="http://www.phppan.com/2011/10/php-design-pattern-proxy-and-reflection/">代理模式(Proxy)和PHP的反射功能</a></li>
</ol>

<h2 id="strategy-pattern">策略模式（Strategy pattern）</h2>
<p>策略模式是一种行为型模式，它定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。策略模式可以使算法可独立于使用它的客户而变化。</p>

<h3 id="section-88">主要角色</h3>

<ul>
  <li>抽象策略(Strategy）角色：定义所有支持的算法的公共接口。通常是以一个接口或抽象来实现。Context使用这个接口来调用其ConcreteStrategy定义的算法</li>
  <li>具体策略(ConcreteStrategy)角色：以Strategy接口实现某具体算法</li>
  <li>环境(Context)角色：持有一个Strategy类的引用，用一个ConcreteStrategy对象来配置</li>
</ul>

<h3 id="section-89">适用性</h3>

<ul>
  <li>许多相关的类仅仅是行为有异。“策略”提供了一种用多个行为中的一个行为来配置一个类的方法</li>
  <li>需要使用一个算法的不同变体。</li>
  <li>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的，与算法相关的数据结构</li>
  <li>一个类定义了多种行为，并且 这些行为在这个类的操作中以多个形式出现。将相关的条件分支移和它们各自的Strategy类中以代替这些条件语句</li>
</ul>

<h3 id="section-90">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-strategy-pattern-uml.jpg" alt="strategy pattern" /></p>

<h3 id="section-91">实例</h3>

<p>```php
&lt;?php
interface Strategy { // 抽象策略角色，以接口实现
    public function algorithmInterface(); // 算法接口
}</p>

<p>class ConcreteStrategyA implements Strategy { // 具体策略角色A 
    public function algorithmInterface() {}
}</p>

<p>class ConcreteStrategyB implements Strategy { // 具体策略角色B 
    public function algorithmInterface() {}
}</p>

<p>class ConcreteStrategyC implements Strategy { // 具体策略角色C
    public function algorithmInterface() {}
}</p>

<p>class Context { // 环境角色
    private $_strategy;
    public function __construct(Strategy $strategy) {
        $this-&gt;_strategy = $strategy;
    } 
    public function contextInterface() {
        $this-&gt;_strategy-&gt;algorithmInterface();
    }
}</p>

<p>// client
$strategyA = new ConcreteStrategyA();
$context = new Context($strategyA);
$context-&gt;contextInterface();</p>

<p>$strategyB = new ConcreteStrategyB();
$context = new Context($strategyB);
$context-&gt;contextInterface();</p>

<p>$strategyC = new ConcreteStrategyC();
$context = new Context($strategyC);
$context-&gt;contextInterface();
?&gt;
```</p>

<h3 id="section-92">优缺点</h3>

<h4 id="section-93">优点</h4>

<ul>
  <li>策略模式提供了管理相关的算法族的办法</li>
  <li>策略模式提供了可以替换继承关系的办法 将算封闭在独立的Strategy类中使得你可以独立于其Context改变它</li>
  <li>使用策略模式可以避免使用多重条件转移语句。</li>
</ul>

<h4 id="section-94">缺点</h4>

<ul>
  <li>客户必须了解所有的策略 这是策略模式一个潜在的缺点</li>
  <li>Strategy和Context之间的通信开销</li>
  <li>策略模式会造成很多的策略类</li>
</ul>

<h3 id="section-95">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Strategy_pattern">Wikipedia: Strategy pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F">Wikipedia: 策略模式</a></li>
  <li><a href="http://www.phppan.com/2010/07/php-design-pattern-12-strategy/">PHP设计模式笔记：使用PHP实现策略模式</a></li>
</ol>

<h2 id="command-pattern">命令模式（Command pattern）</h2>
<p>命令模式是一种行为型模式，它将一个请求封装为一个对象，从而使用你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。</p>

<p>请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p>

<h3 id="section-96">主要角色</h3>

<ul>
  <li>命令（Command）角色：声明了一个给所有具体命令类的抽象接口。这是一个抽象角色。</li>
  <li>具体命令（ConcreteCommand）角色：定义一个接受者和行为之间的弱耦合；实现Execute()方法，负责调用接收考的相应操作。Execute()方法通常叫做执行方法。</li>
  <li>客户（Client）角色：创建了一个具体命令(ConcreteCommand)对象并确定其接收者。</li>
  <li>请求者（Invoker）角色：负责调用命令对象执行请求，相关的方法叫做行动方法。</li>
  <li>接收者（Receiver）角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</li>
</ul>

<h3 id="section-97">适用性</h3>

<ul>
  <li>抽象出待执行的动作以参数化对象。Command模式是回调机制的一个面向对象的替代品。</li>
  <li>在不同的时刻指定、排列和执行请求。</li>
  <li>支持取消操作。</li>
  <li>支持修改日志。</li>
  <li>用构建在原语操作上的高层操作构造一个系统。Command模式提供了对事务进行建模的方法。Command有一个公共的接口，使得你可以用同一种方式调用所有的事务。同时使用该模式也易于添加新事务以扩展系统。</li>
</ul>

<h3 id="section-98">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-command-pattern-uml.jpg" alt="command pattern" /></p>

<h3 id="section-99">实例</h3>

<p>```php
&lt;?php
interface Command { // 命令角色
    public function execute(); // 执行方法
}</p>

<p>class ConcreteCommand implements Command { // 具体命令方法 
    private $_receiver; 
    public function __construct(Receiver $receiver) {
        $this-&gt;_receiver = $receiver;
    }
    public function execute() {
        $this-&gt;_receiver-&gt;action();
    }
}</p>

<p>class Receiver { // 接收者角色
    private $_name;
    public function __construct($name) {
        $this-&gt;_name = $name;
    }
    public function action() { }
}</p>

<p>class Invoker { // 请求者角色
    private $_command; 
    public function __construct(Command $command) {
        $this-&gt;_command = $command;
    }
    public function action() {
        $this-&gt;_command-&gt;execute();
    }
}</p>

<p>$receiver = new Receiver(‘hello world’);
$command = new ConcreteCommand($receiver);
$invoker = new Invoker($command);
$invoker-&gt;action();
?&gt;
```</p>

<h3 id="section-100">优缺点</h3>

<h4 id="section-101">优点</h4>

<ul>
  <li>命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分离开。</li>
  <li>命令类与其他任何别的类一样，可以修改和推广。</li>
  <li>可以把命令对象聚合在一起，合成为合成命令。</li>
  <li>可以很容易的加入新的命令类。</li>
</ul>

<h4 id="section-102">缺点</h4>

<ul>
  <li>可能会导致某些系统有过多的具体命令类。</li>
</ul>

<h3 id="section-103">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Command_pattern">Wikipedia: Command pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F">Wikipedia: 命令模式</a></li>
  <li><a href="http://www.phppan.com/2010/08/php-design-pattern-15-comman/">PHP设计模式笔记：使用PHP实现命令模式</a></li>
</ol>

<h2 id="interpreter-pattern">解释器模式（Interpreter pattern）</h2>
<p>解释器模式是一种行为型模式，它给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</p>

<h3 id="section-104">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-interpreter-pattern-uml.jpg" alt="interpreter pattern" /></p>

<h3 id="section-105">实例</h3>

<p>```php
&lt;?php
class Expression { 
    function interpreter($str) { 
        return $str; 
    } 
}</p>

<p>class ExpressionNum extends Expression { 
    function interpreter($str) { 
        switch($str) { 
            case “0”: return “零”; 
            case “1”: return “一”; 
            case “2”: return “二”; 
            case “3”: return “三”; 
            case “4”: return “四”; 
            case “5”: return “五”; 
            case “6”: return “六”; 
            case “7”: return “七”; 
            case “8”: return “八”; 
            case “9”: return “九”; 
        } 
    } 
}</p>

<p>class ExpressionCharater extends Expression { 
    function interpreter($str) { 
        return strtoupper($str); 
    } 
}</p>

<p>class Interpreter { 
    function execute($string) { 
        $expression = null; 
        for($i = 0;$i&lt;strlen($string);$i++) { 
            $temp = $string[$i]; 
            switch(true) { 
                case is_numeric($temp): $expression = new ExpressionNum(); break; 
                default: $expression = new ExpressionCharater(); 
            } 
            echo $expression-&gt;interpreter($temp); 
        } 
    } 
}</p>

<p>//client
$obj = new Interpreter(); 
$obj-&gt;execute(“12345abc”); 
?&gt;
```</p>

<h3 id="section-106">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Strategy_pattern">Wikipedia: Strategy pattern</a></li>
  <li><a href="http://www.jb51.net/article/27484.htm">php设计模式 Interpreter(解释器模式)</a></li>
</ol>

<h2 id="iterator-pattern">迭代器模式（Iterator pattern）</h2>
<p>迭代器模式是一种行为型模式，它是一种最简单也最常见的设计模式。它可以让使用者透过特定的接口巡访容器中的每一个元素而不用了解底层的实作。</p>

<h3 id="section-107">适用性</h3>

<ul>
  <li>在希望利用语言本身的遍历函数便利自定义结构时，例如PHP中的foreach函数</li>
</ul>

<h3 id="section-108">实例</h3>

<p>```php
&lt;?php
class sample implements Iterator {
    private $_items ;</p>

<pre><code>public function __construct(&amp;$data) {
    $this-&gt;_items = $data;
}
public function current() {
    return current($this-&gt;_items);
}
 
public function next() {
    next($this-&gt;_items);   
}
 
public function key() {
    return key($this-&gt;_items);
}
 
public function rewind() {
    reset($this-&gt;_items);
}
 
public function valid() {                                                                              
    return ($this-&gt;current() !== FALSE);
} }
</code></pre>

<p>// client
$data = array(1, 2, 3, 4, 5);
$sa = new sample($data);
foreach ($sa AS $key =&gt; $row) {
    echo $key, ‘ ‘, $row, ‘<br />’;
}
?&gt;
```</p>

<h3 id="section-109">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Iterator_pattern">Wikipedia: Iterator pattern</a></li>
  <li><a href="http://www.phppan.com/2010/04/php-iterator-and-yii-cmapiterator/">PHP中迭代器的简单实现及Yii框架中的迭代器实现</a></li>
</ol>

<h2 id="mediator-pattern">中介者模式（Mediator pattern）</h2>
<p>中介者模式是一种行为型模式，它包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用，从而使它们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化。</p>

<h3 id="section-110">主要角色</h3>

<ul>
  <li>中介者(Mediator）角色：定义了对象间相互作用的接口</li>
  <li>具体中介者(ConcreteMediator)角色：实现了中介者定义的接口。</li>
  <li>具体对象(ConcreteColleague)角色：通过中介者和别的对象进行交互</li>
</ul>

<h3 id="section-111">实例</h3>

<p>```php
&lt;?php
abstract class Mediator { // 中介者角色
    abstract public function send($message,$colleague); 
}</p>

<p>abstract class Colleague { // 抽象对象
    private $_mediator = null; 
    public function __construct($mediator) { 
        $this-&gt;_mediator = $mediator; 
    } 
    public function send($message) { 
        $this-&gt;_mediator-&gt;send($message,$this); 
    } 
    abstract public function notify($message); 
}</p>

<p>class ConcreteMediator extends Mediator { // 具体中介者角色
    private $_colleague1 = null; 
    private $_colleague2 = null; 
    public function send($message,$colleague) { 
        if($colleague == $this-&gt;_colleague1) { 
            $this-&gt;_colleague1-&gt;notify($message); 
        } else { 
            $this-&gt;_colleague2-&gt;notify($message); 
        } 
    }
    public function set($colleague1,$colleague2) { 
        $this-&gt;_colleague1 = $colleague1; 
        $this-&gt;_colleague2 = $colleague2; 
    } 
}</p>

<p>class Colleague1 extends Colleague { // 具体对象角色
    public function notify($message) { } 
}</p>

<p>class Colleague2 extends Colleague { // 具体对象角色
    public function notify($message) { } 
}</p>

<p>// client
$objMediator = new ConcreteMediator(); 
$objC1 = new Colleague1($objMediator); 
$objC2 = new Colleague2($objMediator); 
$objMediator-&gt;set($objC1,$objC2); 
$objC1-&gt;send(“to c2 from c1”); 
$objC2-&gt;send(“to c1 from c2”); 
?&gt;
```</p>

<h3 id="section-112">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Mediator_pattern">Wikipedia: Mediator pattern</a></li>
</ol>

<h2 id="memento-pattern">备忘录模式（Memento pattern）</h2>
<p>备忘录模式是一种行为型模式，它在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样可以在以后把该对象的状态恢复到之前保存的状态。</p>

<h3 id="section-113">主要角色</h3>

<ul>
  <li>备忘录(Memento)角色：存储发起人(Originator)对象的内部状态，而发起人根据需要决定备忘录存储发起人的哪些内部状态。备忘录可以保护其内容不被发起人(Originator)对象之外的任何对象所读取。</li>
  <li>发起人(Originator)角色：创建一个含有当前的内部状态的备忘录对象，使用备忘录对象存储其内部状态</li>
  <li>负责人(Caretaker)角色：负责保存备忘录对象，不检查备忘录对象的内容</li>
</ul>

<h3 id="section-114">适用性</h3>

<ul>
  <li>必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。</li>
  <li>如果一个用接口来让其它对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</li>
</ul>

<h3 id="section-115">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-memento-pattern-uml.jpg" alt="memento pattern" /></p>

<h3 id="section-116">实例</h3>

<p>```php
&lt;?php
class Originator { // 发起人(Originator)角色
    private $_state;
    public function __construct() {
        $this-&gt;_state = ‘’;
    }
    public function createMemento() { // 创建备忘录
        return new Memento($this-&gt;_state);
    }
    public function restoreMemento(Memento $memento) { // 将发起人恢复到备忘录对象记录的状态上
        $this-&gt;_state = $memento-&gt;getState();
    }
    public function setState($state) { $this-&gt;_state = $state; } 
    public function getState() { return $this-&gt;_state; }
    public function showState() {}</p>

<p>}</p>

<p>class Memento { // 备忘录(Memento)角色 
    private $_state;
    public function __construct($state) {
        $this-&gt;setState($state);
    }
    public function getState() { return $this-&gt;_state; } 
    public function setState($state) { $this-&gt;_state = $state;}
}</p>

<p>class Caretaker { // 负责人(Caretaker)角色 
    private $_memento;
    public function getMemento() { return $this-&gt;_memento; } 
    public function setMemento(Memento $memento) { $this-&gt;_memento = $memento; }
}</p>

<p>// client
/* 创建目标对象 */
$org = new Originator();
$org-&gt;setState(‘open’);
$org-&gt;showState();</p>

<p>/* 创建备忘 */
$memento = $org-&gt;createMemento();</p>

<p>/* 通过Caretaker保存此备忘 */
$caretaker = new Caretaker();
$caretaker-&gt;setMemento($memento);</p>

<p>/* 改变目标对象的状态 */
$org-&gt;setState(‘close’);
$org-&gt;showState();</p>

<p>/* 还原操作 */
$org-&gt;restoreMemento($caretaker-&gt;getMemento());
$org-&gt;showState();
?&gt;
```</p>

<h3 id="section-117">优缺点</h3>

<h4 id="section-118">优点</h4>

<ul>
  <li>有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取。</li>
  <li>简化了发起人(Originator)类。发起人(Originator)不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理它们所需要的这些状态的版本</li>
  <li>当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。</li>
</ul>

<h4 id="section-119">缺点</h4>

<ul>
  <li>如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。</li>
  <li>当负责人角色将一个备忘录存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否会很昂贵。</li>
  <li>当发起人角色的状态改变的时候，有可能这个状态无效。</li>
</ul>

<h3 id="section-120">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Memento_pattern">Wikipedia: Memento pattern</a></li>
  <li><a href="http://www.phppan.com/2010/10/php-design-pattern-18-memento/">PHP设计模式笔记：使用PHP实现备忘录模式</a></li>
</ol>

<h2 id="visitor-pattern">访问者模式（Visitor pattern）</h2>
<p>访问者模式是一种行为型模式，访问者表示一个作用于某对象结构中各元素的操作。它可以在不修改各元素类的前提下定义作用于这些元素的新操作，即动态的增加具体访问者角色。</p>

<p>访问者模式利用了双重分派。先将访问者传入元素对象的Accept方法中，然后元素对象再将自己传入访问者，之后访问者执行元素的相应方法。</p>

<h3 id="section-121">主要角色</h3>

<ul>
  <li>抽象访问者角色(Visitor)：为该对象结构(ObjectStructure)中的每一个具体元素提供一个访问操作接口。该操作接口的名字和参数标识了 要访问的具体元素角色。这样访问者就可以通过该元素角色的特定接口直接访问它。</li>
  <li>具体访问者角色(ConcreteVisitor)：实现抽象访问者角色接口中针对各个具体元素角色声明的操作。</li>
  <li>抽象节点（Node）角色：该接口定义一个accept操作接受具体的访问者。</li>
  <li>具体节点（Node）角色：实现抽象节点角色中的accept操作。</li>
  <li>对象结构角色(ObjectStructure)：这是使用访问者模式必备的角色。它要具备以下特征：能枚举它的元素；可以提供一个高层的接口以允许该访问者访问它的元素；可以是一个复合（组合模式）或是一个集合，如一个列表或一个无序集合(在PHP中我们使用数组代替，因为PHP中的数组本来就是一个可以放置任何类型数据的集合)</li>
</ul>

<h3 id="section-122">适用性</h3>

<ul>
  <li>访问者模式多用在聚集类型多样的情况下。在普通的形式下必须判断每个元素是属于什么类型然后进行相应的操作，从而诞生出冗长的条件转移语句。而访问者模式则可以比较好的解决这个问题。对每个元素统一调用$element-&gt;accept($vistor)即可。</li>
  <li>访问者模式多用于被访问的类结构比较稳定的情况下，即不会随便添加子类。访问者模式允许被访问结构添加新的方法。</li>
</ul>

<h3 id="section-123">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-visitor-pattern-uml.jpg" alt="visitor pattern" /></p>

<h3 id="section-124">实例</h3>

<p>```php
&lt;?php
interface Visitor { // 抽象访问者角色
    public function visitConcreteElementA(ConcreteElementA $elementA);
    public function visitConcreteElementB(concreteElementB $elementB);
}</p>

<p>interface Element { // 抽象节点角色
    public function accept(Visitor $visitor);
}</p>

<p>class ConcreteVisitor1 implements Visitor { // 具体的访问者1
    public function visitConcreteElementA(ConcreteElementA $elementA) {}
    public function visitConcreteElementB(ConcreteElementB $elementB) {}
}</p>

<p>class ConcreteVisitor2 implements Visitor { // 具体的访问者2
    public function visitConcreteElementA(ConcreteElementA $elementA) {}
    public function visitConcreteElementB(ConcreteElementB $elementB) {}
}</p>

<p>class ConcreteElementA implements Element { // 具体元素A
    private $_name;
    public function __construct($name) { $this-&gt;_name = $name; } 
    public function getName() { return $this-&gt;_name; }
    public function accept(Visitor $visitor) { // 接受访问者调用它针对该元素的新方法
        $visitor-&gt;visitConcreteElementA($this);
    }
}</p>

<p>class ConcreteElementB implements Element { // 具体元素B
    private $_name; 
    public function __construct($name) { $this-&gt;_name = $name;}
    public function getName() { return $this-&gt;_name; }
    public function accept(Visitor $visitor) { // 接受访问者调用它针对该元素的新方法
        $visitor-&gt;visitConcreteElementB($this);
    }
}</p>

<p>class ObjectStructure { // 对象结构 即元素的集合
    private $_collection; 
    public function __construct() { $this-&gt;_collection = array(); } 
    public function attach(Element $element) {
        return array_push($this-&gt;_collection, $element);
    }
    public function detach(Element $element) {
        $index = array_search($element, $this-&gt;_collection);
        if ($index !== FALSE) {
            unset($this-&gt;_collection[$index]);
        }
        return $index;
    }
    public function accept(Visitor $visitor) {
        foreach ($this-&gt;_collection as $element) {
            $element-&gt;accept($visitor);
        }
    }
}</p>

<p>// client
$elementA = new ConcreteElementA(“ElementA”);
$elementB = new ConcreteElementB(“ElementB”);
$elementA2 = new ConcreteElementB(“ElementA2”);
$visitor1 = new ConcreteVisitor1();
$visitor2 = new ConcreteVisitor2();</p>

<p>$os = new ObjectStructure();
$os-&gt;attach($elementA);
$os-&gt;attach($elementB);
$os-&gt;attach($elementA2);
$os-&gt;detach($elementA);
$os-&gt;accept($visitor1);
$os-&gt;accept($visitor2);
?&gt;
```</p>

<h3 id="section-125">优缺点</h3>

<h4 id="section-126">优点</h4>

<ul>
  <li>访问者模式使得增加新的操作变得很容易。使用访问者模式可以在不用修改具体元素类的情况下增加新的操作。它主要是通过元素类的accept方法来接受一个新的visitor对象来实现的。如果一些操作依赖于一个复杂的结构对象的话，那么一般而言，增加新的操作会很复杂。而使用访问者模式，增加新的操作就意味着增加一个新的访问者类，因此，变得很容易。</li>
  <li>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。</li>
  <li>访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。迭代子只能访问属于同一个类型等级结构的成员对象，而不能访问属于不同等级结构的对象。访问者模式可以做到这一点。</li>
  <li>积累状态。每一个单独的访问者对象都集中了相关的行为，从而也就可以在访问的过程中将执行操作的状态积累在自己内部，而不是分散到很多的节点对象中。这是有益于系统维护的优点。</li>
</ul>

<h4 id="section-127">缺点</h4>

<ul>
  <li>增加新的节点类变得很困难。每增加一个新的节点都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作。</li>
  <li>破坏封装。访问者模式要求访问者对象访问并调用每一个节点对象的操作，这隐含了一个对所有节点对象的要求：它们必须暴露一些自己的操作和内部状态。不然，访问者的访问就变得没有意义。由于访问者对象自己会积累访问操作所需的状态，从而使这些状态不再存储在节点对象中，这也是破坏封装的。</li>
</ul>

<h3 id="section-128">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Visitor_pattern">Wikipedia: Visitor pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F">Wikipedia: 访问者模式</a></li>
  <li><a href="http://www.phppan.com/2010/05/php-design-pattern-1-visitor/">PHP设计模式笔记：使用PHP实现访问者模式</a></li>
</ol>

<h2 id="strategy-pattern-1">策略模式（Strategy pattern）</h2>
<p>状态模式是一种行为型模式，它允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类，状态模式变化的位置在于对象的状态。</p>

<h3 id="section-129">主要角色</h3>

<ul>
  <li>抽象状态(State)角色：定义一个接口，用以封装环境对象的一个特定的状态所对应的行为</li>
  <li>具体状态（ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为</li>
  <li>环境(Context)角色：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态</li>
</ul>

<h3 id="section-130">适用性</h3>

<ul>
  <li>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为</li>
  <li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式模式将每一个条件分支放入一个独立的类中。这使得你可以要所对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化</li>
</ul>

<h3 id="section-131">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-state-pattern-uml.jpg" alt="state pattern" /></p>

<h3 id="section-132">实例</h3>

<p>```php
&lt;?php
interface State { // 抽象状态角色
    public function handle(Context $context); // 方法示例
}</p>

<p>class ConcreteStateA implements State { // 具体状态角色A
    private static $_instance = null;
    private function __construct() {}
    public static function getInstance() { // 静态工厂方法，返还此类的唯一实例
        if (is_null(self::$_instance)) {
            self::$_instance = new ConcreteStateA();
        }
        return self::$_instance;
    }</p>

<pre><code>public function handle(Context $context) {
    $context-&gt;setState(ConcreteStateB::getInstance());
}
</code></pre>

<p>}</p>

<p>class ConcreteStateB implements State { // 具体状态角色B
    private static $_instance = null;
    private function __construct() {}
    public static function getInstance() {
        if (is_null(self::$_instance)) {
            self::$_instance = new ConcreteStateB();
        }
        return self::$_instance;
    }</p>

<pre><code>public function handle(Context $context) {
    $context-&gt;setState(ConcreteStateA::getInstance());
} }
</code></pre>

<p>class Context { // 环境角色 
    private $_state;
    public function __construct() { // 默认为stateA
        $this-&gt;_state = ConcreteStateA::getInstance();
    }
    public function setState(State $state) {
        $this-&gt;_state = $state;
    }
    public function request() {
        $this-&gt;_state-&gt;handle($this);
    }
}</p>

<p>// client
$context = new Context();
$context-&gt;request();
$context-&gt;request();
$context-&gt;request();
$context-&gt;request();
?&gt;
```</p>

<h3 id="section-133">优缺点</h3>

<h4 id="section-134">优点</h4>

<ul>
  <li>它将与特定状态相关的行为局部化</li>
  <li>它使得状态转换显示化</li>
  <li>State对象可被共享</li>
</ul>

<h3 id="section-135">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/State_pattern">Wikipedia: State pattern</a></li>
  <li><a href="http://www.phppan.com/2010/07/php-design-pattern-11-state/">PHP设计模式笔记：使用PHP实现状态模式</a></li>
</ol>

<h2 id="abstract-factory-pattern">抽象工厂模式（Abstract Factory pattern）</h2>
<p>抽象工厂模式是一种创建型模式，它提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。它的实质是“提供接口，创建一系列相关或独立的对象，而不指定这些对象的具体类”。</p>

<p>抽象工厂模式提供一个创建一系统相关或相互依赖对象的接口，而无需指定它们具体的类。</p>

<h3 id="section-136">抽象工厂模式中主要角色</h3>

<ul>
  <li>抽象工厂(Abstract Factory)角色：它声明创建抽象产品对象的接口</li>
  <li>具体工厂(Concrete Factory)角色：实现创建产品对象的操作</li>
  <li>抽象产品(Abstract Product)角色：声明一类产品的接口</li>
  <li>具体产品(Concrete Product)角色：实现抽象产品角色所定义的接口</li>
</ul>

<p>这个和工厂方法模式类似，我们不再只要一个汉堡，可能是4个汉堡2个鸡翅，我们还是对服务员说，服务员属于具体工厂，抽象产品就是麦当劳可卖的食物，具体产品是我们跟服务员要的食物。</p>

<h3 id="section-137">适用性</h3>

<ul>
  <li>一个系统要独立于它的产品的创建、组合和表示时。</li>
  <li>一个系统要由多个产品系列中的一个来配置时。</li>
  <li>需要强调一系列相关的产品对象的设计以便进行联合使用时。</li>
  <li>提供一个产品类库，而只想显示它们的接口而不是实现时。</li>
</ul>

<h3 id="section-138">类图</h3>
<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-abstract-pattern-uml.png" alt="abstract pattern" /></p>

<h3 id="section-139">实例</h3>

<p>```php
&lt;?php
class Button{}
class Border{}
class MacButton extends Button{}
class WinButton extends Button{}
class MacBorder extends Border{}
class WinBorder extends Border{}</p>

<p>interface AbstractFactory {
    public function CreateButton();
    public function CreateBorder();
}</p>

<p>class MacFactory implements AbstractFactory{
    public function CreateButton(){ return new MacButton(); }
    public function CreateBorder(){ return new MacBorder(); }
}
class WinFactory implements AbstractFactory{
    public function CreateButton(){ return new WinButton(); }
    public function CreateBorder(){ return new WinBorder(); }
}
?&gt;
```</p>

<p>在这里例子中，工厂类实现了一组工厂方法。如果要增加新的功能，可以增加新的接口，让新的工厂类实现这个接口即可，而无需修改现有的工厂类。</p>

<h3 id="section-140">优缺点</h3>

<h4 id="section-141">优点</h4>
<ul>
  <li>分离了具体的类</li>
  <li>使增加或替换产品族变得容易</li>
  <li>有利于产品的一致性</li>
</ul>

<h4 id="section-142">缺点</h4>
<p>难以支持新种类的产品。这是因为AbstractFactory接口确定了可以被创建的产品集合。支持新各类的产品就需要扩展访工厂接口，从而导致AbstractFactory类及其所有子类的改变。</p>

<h3 id="section-143">参考</h3>
<ol>
  <li><a href="http://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">Wikipedia: 抽象工厂</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Abstract_factory_pattern">Wikipedia: Abstract factory pattern</a></li>
  <li><a href="http://www.phppan.com/2010/05/php-design-pattern-3-abstract-factory/">PHP设计模式笔记：使用PHP实现抽象工厂模式</a></li>
</ol>

<h2 id="factory-method-pattern">工厂方法模式（Factory method pattern）</h2>
<p>工厂方法模式是一种创建型模式，这种模式使用“工厂”概念来完成对象的创建而不用具体说明这个对象。</p>

<p>在面向对象程序设计中，工厂通常是一个用来创建其他对象的对象。工厂是构造方法的抽象，用来实现不同的分配方案。</p>

<h3 id="section-144">主要角色</h3>

<ul>
  <li>抽象产品(Product)角色：具体产品对象共有的父类或者接口。</li>
  <li>具体产品(Concrete Product)角色：实现抽象产品角色所定义的接口</li>
  <li>抽象工厂(Creator)角色：它声明了工厂方法，该方法返回Product对象</li>
  <li>具体工厂(Concrete Creator)：实现抽象工厂接口</li>
</ul>

<p>工厂方法模式就像我们去麦当劳买汉堡，我们只要找到服务员，让他帮我们拿来汉堡即可。其中具体某个服务员就像具体工厂，他继承了服务员应有的服务。汉堡在到手以前属于抽象产品，而我们拿到的汉堡就属于具体产品。</p>

<h3 id="section-145">适用性</h3>

<ul>
  <li>创建对象需要大量重复的代码（例如创建一个MySQL操作类，需要配置很多选项，这些都可以在工厂方法中进行）。</li>
  <li>创建对象需要访问某些信息，而这些信息不应该包含在复合类中。</li>
  <li>创建对象的生命周期必须集中管理，以保证在整个程序中具有一致的行为。</li>
</ul>

<h3 id="section-146">类图</h3>
<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-factory-method-uml.png" alt="factory method" /></p>

<h3 id="section-147">实例</h3>

<h4 id="section-148">普通工厂方法</h4>
<p>下面的例子是工厂方法模式的应用，我们要创建两种风格的按钮，只需用不同的工厂方法获得相应按钮类即可。</p>

<p>```php
&lt;?php</p>

<p>class Button{/* …<em>/}
class WinButton extends Button{/</em> …<em>/}
class MacButton extends Button{/</em> …*/}</p>

<p>interface ButtonFactory{
    public function createButton($type);
}</p>

<p>class MyButtonFactory implements ButtonFactory{
    // 实现工厂方法
    public function createButton($type){
        switch($type){
            case ‘Mac’:
                return new MacButton();
            case ‘Win’:
                return new WinButton();
        }
    }
}
?&gt;
```</p>

<p>上例中的<code>createButton()</code>方法即所谓的工厂方法，它所在的类仅仅是这个方法的载体。工厂方法的核心功能是创建类并返回，这个方法可以产生一个类，也可以产生多种类。这个方法本身的载体也并不局限，将其设置为静态方法也是可以的，这个根据自己的情况而定。</p>

<h3 id="section-149">优缺点</h3>

<h4 id="section-150">优点</h4>
<p>工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p>

<h4 id="section-151">缺点</h4>
<ul>
  <li>重构已经存在的类会破坏客户端代码。</li>
  <li>如果工厂方法所在类的构造函数为私有，则工厂方法无法继续扩展，或者必须实现工厂方法所在类的全部依赖方法。</li>
</ul>

<h3 id="section-152">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Wikipedia: Factory method pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">Wikipedia: 工厂方法模式</a></li>
  <li><a href="http://www.phppan.com/2010/07/php-design-pattern-9-factory-method/">PHP设计模式笔记：使用PHP实现工厂模式</a></li>
</ol>

<h2 id="template-method-pattern">模板方法模式（Template method pattern）</h2>
<p>模板方法模式模式是一种行为型模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以在不改变一个算法的结构的情况下重定义该算法的某些特定的步骤。</p>

<h3 id="section-153">主要角色</h3>

<h4 id="abstractclass">抽象模板(AbstractClass)角色</h4>
<p>定义一个或多个抽象方法让子类实现。这些抽象方法叫做基本操作，它们是顶级逻辑的组成部分。</p>

<p>定义一个模板方法。这个模板方法一般是一个具体方法，它给出顶级逻辑的骨架，而逻辑的组成步骤在对应的抽象操作中，这些操作将会推迟到子类中实现。同时，顶层逻辑也可以调用具体的实现方法</p>

<h5 id="concrteclass">具体模板(ConcrteClass)角色</h5>
<p>实现父类的一个或多个抽象方法，作为顶层逻辑的组成而存在。</p>

<p>每个抽象模板可以有多个具体模板与之对应，而每个具体模板有其自己对抽象方法（也就是顶层逻辑的组成部分）的实现，从而使得顶层逻辑的实现各不相同。</p>

<h3 id="section-154">适用性</h3>

<ul>
  <li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li>
  <li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li>
  <li>控制子类扩展。</li>
</ul>

<h3 id="section-155">类图</h3>

<p><img src="https://www.tuchuang001.com/images/2017/05/20/tech-template-method-pattern-uml.jpg" alt="template method pattern" /></p>

<h3 id="section-156">实例</h3>

<p>```php
&lt;?php
abstract class AbstractClass { // 抽象模板角色
    public function templateMethod() { // 模板方法 调用基本方法组装顶层逻辑
        $this-&gt;primitiveOperation1();
        $this-&gt;primitiveOperation2();
    }
    abstract protected function primitiveOperation1(); // 基本方法
    abstract protected function primitiveOperation2();
}</p>

<p>class ConcreteClass extends AbstractClass { // 具体模板角色
    protected function primitiveOperation1() {}
    protected function primitiveOperation2(){}</p>

<p>}</p>

<p>$class = new ConcreteClass();
$class-&gt;templateMethod();
?&gt;
```</p>

<h3 id="section-157">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Template_method_pattern">Wikipedia: Template method pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">Wikipedia: 模板方法模式</a></li>
  <li><a href="http://www.phppan.com/2010/09/php-design-pattern-16-template-method/">PHP设计模式笔记：使用PHP实现模板方法模式</a></li>
</ol>

<h2 id="chain-of-responsibility-pattern">责任链模式（Chain of responsibility pattern）</h2>
<p>责任链模式是一种行为型模式，它包含了一些命令对象和一系列的处理对象。每一个处理对象决定它能处理哪些命令对象，它也知道如何将它不能处理的命令对象传递给该链中的下一个处理对象。该模式还描述了往该处理链的末尾添加新的处理对象的方法。</p>

<h3 id="section-158">主要角色</h3>

<ul>
  <li>抽象责任(Responsibility）角色：定义所有责任支持的公共方法。</li>
  <li>具体责任(Concrete Responsibility)角色：以抽象责任接口实现的具体责任</li>
  <li>责任链(Chain of responsibility)角色：设定责任的调用规则</li>
</ul>

<h3 id="section-159">实例</h3>

<p>```php
&lt;?php
abstract class Responsibility { // 抽象责任角色
    protected $next; // 下一个责任角色</p>

<pre><code>public function setNext(Responsibility $l) {
    $this-&gt;next = $l;
    return $this;
}
abstract public function operate(); // 操作方法 }
</code></pre>

<p>class ResponsibilityA extends Responsibility {
    public function __construct() {}
    public function operate(){
        if (false == is_null($this-&gt;next)) {
            $this-&gt;next-&gt;operate();
        }
    };
}</p>

<p>class ResponsibilityB extends Responsibility {
    public function __construct() {}
    public function operate(){
        if (false == is_null($this-&gt;next)) {
            $this-&gt;next-&gt;operate();
        }
    };
}</p>

<p>$res_a = new ResponsibilityA();
$res_b = new ResponsibilityB();
$res_a-&gt;setNext($res_b);
?&gt;
```</p>

<h3 id="section-160">参考</h3>
<ol>
  <li><a href="http://en.wikipedia.org/wiki/Chain_of_responsibility_pattern">Wikipedia: Chain-of-responsibility pattern</a></li>
  <li><a href="http://zh.wikipedia.org/wiki/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F">Wikipedia: 责任链模式</a></li>
</ol>

        <!--百度分享-->
     <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more">分享到：</a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博">新浪微博</a><a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友">QQ好友</a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间">QQ空间</a><a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧">百度贴吧</a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信">微信</a><a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网">豆瓣网</a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网">人人网</a></div>
     <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"share":{"bdSize":16},"image":{"viewList":["tsina","sqq","qzone","tieba","weixin","douban","renren"],"viewText":"分享到：","viewSize":"24"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","sqq","qzone","tieba","weixin","douban","renren"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
        <!--网易云跟贴-->
        <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    </article>
</div>

<!-- 引入google code pretiffy -->
<script src="/js/jquery.min.js"></script>
<script src="/js/google-code-prettify/prettify.js"></script>
<script type="text/javascript">
    $(function(){
      $("pre").addClass("prettyprint linenums");
      prettyPrint();
      });
    </script>

<!-- 添加博文分割线 -->
<hr class="post-list__divider" />
<section>
       <ul class="pager">
        
        <li class="previous">
            <a href="/2014/04/16/insert-large-number-of-data-in-mysql.html" data-toggle="tooltip" data-placement="top" title="MySQL大量数据插入方法性能分析比较">上一篇：  <span>MySQL大量数据插入方法性能分析比较</span>
            </a>
        </li>
        
        
        <li class="next">
            <a href="/2014/04/23/roc-curve.html" data-toggle="tooltip" data-placement="top" title="ROC曲线">下一篇：  <span>ROC曲线</span>
            </a>
        </li>
        
    </ul>
</section>


<!-- 多说评论框 start -->



        <footer>
  &copy; 2015-2017 喵喵清吟,blog.mana.love <br/>Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> Themes <a href="http://github.com/renyuanz/leonids/" target="_blank">Leonids</a>
</footer>




      </div>
    </div>
  </div>
  <script type="text/javascript" src="https://blog.mana.love/js/jquery-2.1.4.min.js"></script>
<script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>
<script type="text/javascript" src="https://blog.mana.love/js/main.js"></script>
<!--访问量统计工具 Hit Kounter v0.2-->
<script src="https://blog.mana.love/js/av-mini-0.6.10.js"></script>
<script src="https://blog.mana.love/js/hit-kounter-lc-0.2.0.js"></script>
<script type="text/javascript">
    var cloudTieConfig = {
        url: document.location.href,
        sourceId: "",
        productKey: "86a52c1e48c0450385a25e49e7c984cd",
        target: "cloud-tie-wrapper"
    };
    var yunManualLoad = true;
    Tie.loader("aHR0cHM6Ly9hcGkuZ2VudGllLjE2My5jb20vcGMvbGl2ZXNjcmlwdC5odG1s", true);
</script>


</body>
</html>
